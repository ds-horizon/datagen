package main

import (
	"fmt"
	"log/slog"
	"slices"
)

func __dgi_orchestrateSinks(topologicallySorted []string, allData map[string][]__dgi_Record, cfg *__dgi_Config) error {
     if cfg.ClearData {
     	slog.Info("clearing existing data from sinks")
        if err := __dgi_clearAllData(topologicallySorted, allData, cfg); err != nil {
	   return fmt.Errorf("error in clearing data: %w", err)
	}
     }

     slog.Info("loading data into sinks")
     return __dgi_loadAllData(topologicallySorted, allData, cfg)
}

func __dgi_clearAllData(topologicallySorted []string, allData map[string][]__dgi_Record, cfg *__dgi_Config) error {
	reversedTopologicallySorted := slices.Clone(topologicallySorted)
	slices.Reverse(reversedTopologicallySorted)
slog.Debug(fmt.Sprintf("clearing data in reverse topological order: %v", reversedTopologicallySorted))
	for _, name := range reversedTopologicallySorted {
		if _, ok := allData[name]; !ok {
		       continue
		}

        if err := __dgi_clearModelSinks(name, allData[name], cfg); err != nil {
            	   return fmt.Errorf("error clearing sinks for model %s: %w", name, err)
		}
	}
	slog.Info("data deletion completed successfully")
	return nil
}

func __dgi_loadAllData(topologicallySorted []string, allData map[string][]__dgi_Record, cfg *__dgi_Config) error {
    slog.Debug(fmt.Sprintf("loading data in topological order: %v", topologicallySorted))
     for _, name := range topologicallySorted {
     	    	records, ok := allData[name]
		if !ok {
		       continue
		}

        if err := __dgi_loadModelSinks(name, records, cfg); err != nil {
		   return fmt.Errorf("%q, skipping further models", err)
		}
	}
	slog.Info("data loading completed successfully")
	return nil
}

// clearModelSinks routes model records to configured sinks per config.json
func __dgi_clearModelSinks(modelName string, records []__dgi_Record, cfg *__dgi_Config) error {
	sinks, err := cfg.SinkSpecsForModel(modelName)
	if err != nil {
		return fmt.Errorf("error while getting sink specs for model %s: %w", modelName, err)
	}

slog.Debug(fmt.Sprintf("clearing %s from %d sinks", modelName, len(sinks)))
	for _, s := range sinks {
        switch s.SinkType {
        	case __dgi_SinkTypeMySQL:
            err := __dgi_clearMysqlSink(s, modelName)
			if err != nil {
				return fmt.Errorf("error while clearing MySQL sink %s: %w", s.SinkName, err)
			}
		default:
			return fmt.Errorf("unsupported sink_type %q for model %q", s.SinkType, modelName)
		}
	}
	return nil
}

// loadModelSinks routes model records to configured sinks per config.json
func __dgi_loadModelSinks(modelName string, records []__dgi_Record, cfg *__dgi_Config) error {
	sinks, err := cfg.SinkSpecsForModel(modelName)
	if err != nil {
		return fmt.Errorf("error while getting sink specs for model %s: %w", modelName, err)
	}

slog.Debug(fmt.Sprintf("loading %s to %d sinks with %d records", modelName, len(sinks), len(records)))
	for _, s := range sinks {
        switch s.SinkType {
        	case __dgi_SinkTypeMySQL:
            err := __dgi_loadMysqlSink(s, modelName, records)
			if err != nil {
				return fmt.Errorf("error in loading MySQL sink %s: %w", s.SinkName, err)
			}
		default:
			return fmt.Errorf("unsupported sink_type %q for model %q", s.SinkType, modelName)
		}
	}
	return nil
}

func __dgi_loadMysqlSink(sinkSpec *__dgi_SinkSpec, modelName string, records []__dgi_Record) error {
    var sc __dgi_MySQLConfig
    if err := sinkSpec.ConfigInto(&sc); err != nil {
		return fmt.Errorf("mysql sink %q config: %w", sinkSpec.SinkName, err)
	}

	if sc.BatchSize <= 0 {
		sc.BatchSize = len(records)
	}

	switch modelName {
	{{- range $i, $sanitised := .SanitisedModelNames}}
	case "{{$sanitised}}":
        typed := make([]*__datagen_{{index $.FullyQualifiedModelNames $i}}, 0, len(records))
		for _, r := range records {
			typed = append(typed, r.(*__datagen_{{index $.FullyQualifiedModelNames $i}}))
		}

        return Sink_mysql___datagen_{{index $.FullyQualifiedModelNames $i}}_data(modelName, typed, &sc)
	{{- end}}
	default:
		return fmt.Errorf("mysql sink not implemented for model %q", modelName)
	}
}

func __dgi_clearMysqlSink(sinkSpec *__dgi_SinkSpec, modelName string) error {
    var sc __dgi_MySQLConfig
    if err := sinkSpec.ConfigInto(&sc); err != nil {
		return fmt.Errorf("mysql sink %q config: %w", sinkSpec.SinkName, err)
	}

	switch modelName {
	{{- range $i, $sanitised := .SanitisedModelNames}}
	case "{{$sanitised}}":
        return Clear_mysql___datagen_{{index $.FullyQualifiedModelNames $i}}_data(modelName, &sc)
	{{- end}}
	default:
		return fmt.Errorf("mysql sink not implemented for model %q", modelName)
	}
}


func __dgi_getRecordCount(cfg *__dgi_Config, modelName string, metadata __dgi_Metadata) int {
       for _, m := range cfg.Models {
		if m.ModelName == modelName {
			if m.Count != nil {
				return *m.Count
			}
			return metadata.Count
		}
	}

	return metadata.Count
}
